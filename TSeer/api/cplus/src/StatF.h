/**
 * Tencent is pleased to support the open source community by making Tseer available.
 *
 * Copyright (C) 2018 THL A29 Limited, a Tencent company. All rights reserved.
 * 
 * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * https://opensource.org/licenses/BSD-3-Clause
 *
 * Unless required by applicable law or agreed to in writing, software distributed 
 * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 3.2.1.9 by WSRD Tencent.
// Generated from `./StatF.tars'
// **********************************************************************

#ifndef __STATF_H_
#define __STATF_H_

#include <map>
#include <string>
#include <vector>
#include "Tars.h"
using namespace std;


namespace Tseerapi
{
    struct StatMicMsgHead : public Tseer::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.StatMicMsgHead";
        }
        static string MD5()
        {
            return "82469c9496b8aa2d416fd861a3c753e6";
        }
        StatMicMsgHead()
        :masterName(""),slaveName(""),interfaceName(""),masterIp(""),slaveIp(""),slaEpVecort(0),returnValue(0),slaveSetName(""),slaveSetArea(""),slaveSetID(""),tarsVersion(""),sMasterSetInfo(""),sSlaveContainer(""),sMasterContainer(""),iStatVer(1)
        {
        }
        void resetDefautlt()
        {
            masterName = "";
            slaveName = "";
            interfaceName = "";
            masterIp = "";
            slaveIp = "";
            slaEpVecort = 0;
            returnValue = 0;
            slaveSetName = "";
            slaveSetArea = "";
            slaveSetID = "";
            tarsVersion = "";
            sMasterSetInfo = "";
            sSlaveContainer = "";
            sMasterContainer = "";
            iStatVer = 1;
        }
        template<typename WriterT>
        void writeTo(Tseer::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(masterName, 0);
            _os.write(slaveName, 1);
            _os.write(interfaceName, 2);
            _os.write(masterIp, 3);
            _os.write(slaveIp, 4);
            _os.write(slaEpVecort, 5);
            _os.write(returnValue, 6);
            _os.write(slaveSetName, 7);
            _os.write(slaveSetArea, 8);
            _os.write(slaveSetID, 9);
            _os.write(tarsVersion, 10);
            _os.write(sMasterSetInfo, 11);
            _os.write(sSlaveContainer, 12);
            _os.write(sMasterContainer, 13);
            _os.write(iStatVer, 14);
        }
        template<typename ReaderT>
        void readFrom(Tseer::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(masterName, 0, true);
            _is.read(slaveName, 1, true);
            _is.read(interfaceName, 2, true);
            _is.read(masterIp, 3, true);
            _is.read(slaveIp, 4, true);
            _is.read(slaEpVecort, 5, true);
            _is.read(returnValue, 6, true);
            _is.read(slaveSetName, 7, false);
            _is.read(slaveSetArea, 8, false);
            _is.read(slaveSetID, 9, false);
            _is.read(tarsVersion, 10, false);
            _is.read(sMasterSetInfo, 11, false);
            _is.read(sSlaveContainer, 12, false);
            _is.read(sMasterContainer, 13, false);
            _is.read(iStatVer, 14, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            Tseer::TarsDisplayer _ds(_os, _level);
            _ds.display(masterName,"masterName");
            _ds.display(slaveName,"slaveName");
            _ds.display(interfaceName,"interfaceName");
            _ds.display(masterIp,"masterIp");
            _ds.display(slaveIp,"slaveIp");
            _ds.display(slaEpVecort,"slaEpVecort");
            _ds.display(returnValue,"returnValue");
            _ds.display(slaveSetName,"slaveSetName");
            _ds.display(slaveSetArea,"slaveSetArea");
            _ds.display(slaveSetID,"slaveSetID");
            _ds.display(tarsVersion,"tarsVersion");
            _ds.display(sMasterSetInfo,"sMasterSetInfo");
            _ds.display(sSlaveContainer,"sSlaveContainer");
            _ds.display(sMasterContainer,"sMasterContainer");
            _ds.display(iStatVer,"iStatVer");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            Tseer::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(masterName, true);
            _ds.displaySimple(slaveName, true);
            _ds.displaySimple(interfaceName, true);
            _ds.displaySimple(masterIp, true);
            _ds.displaySimple(slaveIp, true);
            _ds.displaySimple(slaEpVecort, true);
            _ds.displaySimple(returnValue, true);
            _ds.displaySimple(slaveSetName, true);
            _ds.displaySimple(slaveSetArea, true);
            _ds.displaySimple(slaveSetID, true);
            _ds.displaySimple(tarsVersion, true);
            _ds.displaySimple(sMasterSetInfo, true);
            _ds.displaySimple(sSlaveContainer, true);
            _ds.displaySimple(sMasterContainer, true);
            _ds.displaySimple(iStatVer, false);
            return _os;
        }
    public:
        std::string masterName;
        std::string slaveName;
        std::string interfaceName;
        std::string masterIp;
        std::string slaveIp;
        Tseer::Int32 slaEpVecort;
        Tseer::Int32 returnValue;
        std::string slaveSetName;
        std::string slaveSetArea;
        std::string slaveSetID;
        std::string tarsVersion;
        std::string sMasterSetInfo;
        std::string sSlaveContainer;
        std::string sMasterContainer;
        Tseer::Int32 iStatVer;
    };
    inline bool operator==(const StatMicMsgHead&l, const StatMicMsgHead&r)
    {
        return l.masterName == r.masterName && l.slaveName == r.slaveName && l.interfaceName == r.interfaceName && l.masterIp == r.masterIp && l.slaveIp == r.slaveIp && l.slaEpVecort == r.slaEpVecort && l.returnValue == r.returnValue && l.slaveSetName == r.slaveSetName && l.slaveSetArea == r.slaveSetArea && l.slaveSetID == r.slaveSetID && l.tarsVersion == r.tarsVersion && l.sMasterSetInfo == r.sMasterSetInfo && l.sSlaveContainer == r.sSlaveContainer && l.sMasterContainer == r.sMasterContainer && l.iStatVer == r.iStatVer;
    }
    inline bool operator!=(const StatMicMsgHead&l, const StatMicMsgHead&r)
    {
        return !(l == r);
    }
    inline bool operator<(const StatMicMsgHead&l, const StatMicMsgHead&r)
    {
        if(l.masterName != r.masterName)  return (l.masterName < r.masterName);
        if(l.slaveName != r.slaveName)  return (l.slaveName < r.slaveName);
        if(l.interfaceName != r.interfaceName)  return (l.interfaceName < r.interfaceName);
        if(l.masterIp != r.masterIp)  return (l.masterIp < r.masterIp);
        if(l.slaveIp != r.slaveIp)  return (l.slaveIp < r.slaveIp);
        if(l.slaEpVecort != r.slaEpVecort)  return (l.slaEpVecort < r.slaEpVecort);
        if(l.returnValue != r.returnValue)  return (l.returnValue < r.returnValue);
        if(l.slaveSetName != r.slaveSetName)  return (l.slaveSetName < r.slaveSetName);
        if(l.slaveSetArea != r.slaveSetArea)  return (l.slaveSetArea < r.slaveSetArea);
        if(l.slaveSetID != r.slaveSetID)  return (l.slaveSetID < r.slaveSetID);
        if(l.tarsVersion != r.tarsVersion)  return (l.tarsVersion < r.tarsVersion);
        if(l.sMasterSetInfo != r.sMasterSetInfo)  return (l.sMasterSetInfo < r.sMasterSetInfo);
        if(l.sSlaveContainer != r.sSlaveContainer)  return (l.sSlaveContainer < r.sSlaveContainer);
        if(l.sMasterContainer != r.sMasterContainer)  return (l.sMasterContainer < r.sMasterContainer);
        if(l.iStatVer != r.iStatVer)  return (l.iStatVer < r.iStatVer);
        return false;
    }
    inline bool operator<=(const StatMicMsgHead&l, const StatMicMsgHead&r)
    {
        return !(r < l);
    }
    inline bool operator>(const StatMicMsgHead&l, const StatMicMsgHead&r)
    {
        return r < l;
    }
    inline bool operator>=(const StatMicMsgHead&l, const StatMicMsgHead&r)
    {
        return !(l < r);
    }

    struct StatMicMsgBody : public Tseer::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.StatMicMsgBody";
        }
        static string MD5()
        {
            return "5be1d7cb771a2e64ee5013d4f743ff7d";
        }
        StatMicMsgBody()
        :count(0),timeoutCount(0),execCount(0),totalRspTime(0),maxRspTime(0),minRspTime(0),weightValue(0),weightCount(0)
        {
        }
        void resetDefautlt()
        {
            count = 0;
            timeoutCount = 0;
            execCount = 0;
            totalRspTime = 0;
            maxRspTime = 0;
            minRspTime = 0;
            weightValue = 0;
            weightCount = 0;
        }
        template<typename WriterT>
        void writeTo(Tseer::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(count, 0);
            _os.write(timeoutCount, 1);
            _os.write(execCount, 2);
            _os.write(intervalCount, 3);
            _os.write(totalRspTime, 4);
            _os.write(maxRspTime, 5);
            _os.write(minRspTime, 6);
            _os.write(retValue, 7);
            _os.write(weightValue, 8);
            _os.write(weightCount, 9);
        }
        template<typename ReaderT>
        void readFrom(Tseer::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(count, 0, true);
            _is.read(timeoutCount, 1, true);
            _is.read(execCount, 2, true);
            _is.read(intervalCount, 3, true);
            _is.read(totalRspTime, 4, true);
            _is.read(maxRspTime, 5, true);
            _is.read(minRspTime, 6, true);
            _is.read(retValue, 7, false);
            _is.read(weightValue, 8, false);
            _is.read(weightCount, 9, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            Tseer::TarsDisplayer _ds(_os, _level);
            _ds.display(count,"count");
            _ds.display(timeoutCount,"timeoutCount");
            _ds.display(execCount,"execCount");
            _ds.display(intervalCount,"intervalCount");
            _ds.display(totalRspTime,"totalRspTime");
            _ds.display(maxRspTime,"maxRspTime");
            _ds.display(minRspTime,"minRspTime");
            _ds.display(retValue,"retValue");
            _ds.display(weightValue,"weightValue");
            _ds.display(weightCount,"weightCount");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            Tseer::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(count, true);
            _ds.displaySimple(timeoutCount, true);
            _ds.displaySimple(execCount, true);
            _ds.displaySimple(intervalCount, true);
            _ds.displaySimple(totalRspTime, true);
            _ds.displaySimple(maxRspTime, true);
            _ds.displaySimple(minRspTime, true);
            _ds.displaySimple(retValue, true);
            _ds.displaySimple(weightValue, true);
            _ds.displaySimple(weightCount, false);
            return _os;
        }
    public:
        Tseer::Int32 count;
        Tseer::Int32 timeoutCount;
        Tseer::Int32 execCount;
        map<Tseer::Int32, Tseer::Int32> intervalCount;
        Tseer::Int64 totalRspTime;
        Tseer::Int32 maxRspTime;
        Tseer::Int32 minRspTime;
        map<Tseer::Int64, Tseer::Int32> retValue;
        Tseer::Int32 weightValue;
        Tseer::Int32 weightCount;
    };
    inline bool operator==(const StatMicMsgBody&l, const StatMicMsgBody&r)
    {
        return l.count == r.count && l.timeoutCount == r.timeoutCount && l.execCount == r.execCount && l.intervalCount == r.intervalCount && l.totalRspTime == r.totalRspTime && l.maxRspTime == r.maxRspTime && l.minRspTime == r.minRspTime && l.retValue == r.retValue && l.weightValue == r.weightValue && l.weightCount == r.weightCount;
    }
    inline bool operator!=(const StatMicMsgBody&l, const StatMicMsgBody&r)
    {
        return !(l == r);
    }
}

#define tars_StatMicMsgHead_TARS_COPY_STRUCT_HELPER   \
        tars_copy_struct(a.masterName,b.masterName);tars_copy_struct(a.slaveName,b.slaveName);tars_copy_struct(a.interfaceName,b.interfaceName);tars_copy_struct(a.masterIp,b.masterIp);tars_copy_struct(a.slaveIp,b.slaveIp);tars_copy_struct(a.slaEpVecort,b.slaEpVecort);tars_copy_struct(a.returnValue,b.returnValue);tars_copy_struct(a.slaveSetName,b.slaveSetName);tars_copy_struct(a.slaveSetArea,b.slaveSetArea);tars_copy_struct(a.slaveSetID,b.slaveSetID);tars_copy_struct(a.tarsVersion,b.tarsVersion);tars_copy_struct(a.sMasterSetInfo,b.sMasterSetInfo);tars_copy_struct(a.sSlaveContainer,b.sSlaveContainer);tars_copy_struct(a.sMasterContainer,b.sMasterContainer);tars_copy_struct(a.iStatVer,b.iStatVer);

#define tars_StatMicMsgBody_TARS_COPY_STRUCT_HELPER   \
        tars_copy_struct(a.count,b.count);tars_copy_struct(a.timeoutCount,b.timeoutCount);tars_copy_struct(a.execCount,b.execCount);tars_copy_struct(a.intervalCount,b.intervalCount);tars_copy_struct(a.totalRspTime,b.totalRspTime);tars_copy_struct(a.maxRspTime,b.maxRspTime);tars_copy_struct(a.minRspTime,b.minRspTime);tars_copy_struct(a.retValue,b.retValue);tars_copy_struct(a.weightValue,b.weightValue);tars_copy_struct(a.weightCount,b.weightCount);

#define tars_StatSampleMsg_TARS_COPY_STRUCT_HELPER   \
        tars_copy_struct(a.unid,b.unid);tars_copy_struct(a.masterName,b.masterName);tars_copy_struct(a.slaveName,b.slaveName);tars_copy_struct(a.interfaceName,b.interfaceName);tars_copy_struct(a.masterIp,b.masterIp);tars_copy_struct(a.slaveIp,b.slaveIp);tars_copy_struct(a.depth,b.depth);tars_copy_struct(a.width,b.width);tars_copy_struct(a.parentWidth,b.parentWidth);

#define tars_ProxyInfo_TARS_COPY_STRUCT_HELPER   \
        tars_copy_struct(a.bFromClient,b.bFromClient);



#endif
