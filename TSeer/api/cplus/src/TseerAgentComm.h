/**
 * Tencent is pleased to support the open source community by making Tseer available.
 *
 * Copyright (C) 2018 THL A29 Limited, a Tencent company. All rights reserved.
 * 
 * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * https://opensource.org/licenses/BSD-3-Clause
 *
 * Unless required by applicable law or agreed to in writing, software distributed 
 * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 1.0.1.
// **********************************************************************

#ifndef __TSEERAGENTCOMM_H_
#define __TSEERAGENTCOMM_H_

#include <map>
#include <string>
#include <vector>
#include "Tars.h"


namespace Tseer
{
    enum LB_GET_TYPE
    {
        GET_IDC,
        GET_SET,
        GET_ALL,
    };
    inline std::string etos(const LB_GET_TYPE & e)
    {
        switch(e)
        {
            case GET_IDC: return "GET_IDC";
            case GET_SET: return "GET_SET";
            case GET_ALL: return "GET_ALL";
            default: return "";
        }
    }
    inline int stoe(const std::string & s, LB_GET_TYPE & e)
    {
        if(s == "GET_IDC")  { e=GET_IDC; return 0;}
        if(s == "GET_SET")  { e=GET_SET; return 0;}
        if(s == "GET_ALL")  { e=GET_ALL; return 0;}

        return -1;
    }

    enum LB_TYPE
    {
        LB_TYPE_LOOP,
        LB_TYPE_RANDOM,
        LB_TYPE_STATIC_WEIGHT,
        LB_TYPE_CST_HASH,
        LB_TYPE_ALL,
    };
    inline std::string etos(const LB_TYPE & e)
    {
        switch(e)
        {
            case LB_TYPE_LOOP: return "LB_TYPE_LOOP";
            case LB_TYPE_RANDOM: return "LB_TYPE_RANDOM";
            case LB_TYPE_STATIC_WEIGHT: return "LB_TYPE_STATIC_WEIGHT";
            case LB_TYPE_CST_HASH: return "LB_TYPE_CST_HASH";
            case LB_TYPE_ALL: return "LB_TYPE_ALL";
            default: return "";
        }
    }
    inline int stoe(const std::string & s, LB_TYPE & e)
    {
        if(s == "LB_TYPE_LOOP")  { e=LB_TYPE_LOOP; return 0;}
        if(s == "LB_TYPE_RANDOM")  { e=LB_TYPE_RANDOM; return 0;}
        if(s == "LB_TYPE_STATIC_WEIGHT")  { e=LB_TYPE_STATIC_WEIGHT; return 0;}
        if(s == "LB_TYPE_CST_HASH")  { e=LB_TYPE_CST_HASH; return 0;}
        if(s == "LB_TYPE_ALL")  { e=LB_TYPE_ALL; return 0;}

        return -1;
    }

    struct AgentRouterRequest : public Tseerapi::TarsStructBase
    {
    public:
        static std::string className()
        {
            return "Tseer.AgentRouterRequest";
        }
        static std::string MD5()
        {
            return "9af915d889472863a9bb593ae523a2ff";
        }
        AgentRouterRequest()
        :getType(Tseer::GET_IDC),lbType(Tseer::LB_TYPE_LOOP),obj(""),setname(""),apiVer(""),hashKey(0),identifier("")
        {
        }
        void resetDefautlt()
        {
            obj = "";
            setname = "";
            apiVer = "";
            hashKey = 0;
            identifier = "";
        }
        template<typename WriterT>
        void writeTo(Tseerapi::TarsOutputStream<WriterT>& _os) const
        {
            _os.write((Tseerapi::Int32)getType, 1);
            _os.write((Tseerapi::Int32)lbType, 2);
            if (obj != "")
            {
                _os.write(obj, 3);
            }
            if (setname != "")
            {
                _os.write(setname, 4);
            }
            if (apiVer != "")
            {
                _os.write(apiVer, 6);
            }
            if (hashKey != 0)
            {
                _os.write(hashKey, 7);
            }
            if (identifier != "")
            {
                _os.write(identifier, 8);
            }
        }
        template<typename ReaderT>
        void readFrom(Tseerapi::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            Tseerapi::Int32 eTemp1 = Tseer::GET_IDC;
            _is.read(eTemp1, 1, false);
            getType = (Tseer::LB_GET_TYPE)eTemp1;
            Tseerapi::Int32 eTemp2 = Tseer::LB_TYPE_LOOP;
            _is.read(eTemp2, 2, false);
            lbType = (Tseer::LB_TYPE)eTemp2;
            _is.read(obj, 3, false);
            _is.read(setname, 4, false);
            _is.read(apiVer, 6, false);
            _is.read(hashKey, 7, false);
            _is.read(identifier, 8, false);
        }
        std::ostream& display(std::ostream& _os, int _level=0) const
        {
            Tseerapi::TarsDisplayer _ds(_os, _level);
            _ds.display((Tseerapi::Int32)getType,"getType");
            _ds.display((Tseerapi::Int32)lbType,"lbType");
            _ds.display(obj,"obj");
            _ds.display(setname,"setname");
            _ds.display(apiVer,"apiVer");
            _ds.display(hashKey,"hashKey");
            _ds.display(identifier,"identifier");
            return _os;
        }
        std::ostream& displaySimple(std::ostream& _os, int _level=0) const
        {
            Tseerapi::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple((Tseerapi::Int32)getType, true);
            _ds.displaySimple((Tseerapi::Int32)lbType, true);
            _ds.displaySimple(obj, true);
            _ds.displaySimple(setname, true);
            _ds.displaySimple(apiVer, true);
            _ds.displaySimple(hashKey, true);
            _ds.displaySimple(identifier, false);
            return _os;
        }
    public:
        Tseer::LB_GET_TYPE getType;
        Tseer::LB_TYPE lbType;
        std::string obj;
        std::string setname;
        std::string apiVer;
        Tseerapi::Int64 hashKey;
        std::string identifier;
    };
    inline bool operator==(const AgentRouterRequest&l, const AgentRouterRequest&r)
    {
        return l.getType == r.getType && l.lbType == r.lbType && l.obj == r.obj && l.setname == r.setname && l.apiVer == r.apiVer && l.hashKey == r.hashKey && l.identifier == r.identifier;
    }
    inline bool operator!=(const AgentRouterRequest&l, const AgentRouterRequest&r)
    {
        return !(l == r);
    }

    struct RouterNodeInfo : public Tseerapi::TarsStructBase
    {
    public:
        static std::string className()
        {
            return "Tseer.RouterNodeInfo";
        }
        static std::string MD5()
        {
            return "edade3358b14bb122556e5492934dfc9";
        }
        RouterNodeInfo()
        :ip(""),port(0),isTcp(true),weight(0),setname("")
        {
        }
        void resetDefautlt()
        {
            ip = "";
            port = 0;
            isTcp = true;
            weight = 0;
            setname = "";
        }
        template<typename WriterT>
        void writeTo(Tseerapi::TarsOutputStream<WriterT>& _os) const
        {
            if (ip != "")
            {
                _os.write(ip, 1);
            }
            if (port != 0)
            {
                _os.write(port, 2);
            }
            if (isTcp != true)
            {
                _os.write(isTcp, 3);
            }
            if (weight != 0)
            {
                _os.write(weight, 4);
            }
            if (setname != "")
            {
                _os.write(setname, 5);
            }
        }
        template<typename ReaderT>
        void readFrom(Tseerapi::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ip, 1, false);
            _is.read(port, 2, false);
            _is.read(isTcp, 3, false);
            _is.read(weight, 4, false);
            _is.read(setname, 5, false);
        }
        std::ostream& display(std::ostream& _os, int _level=0) const
        {
            Tseerapi::TarsDisplayer _ds(_os, _level);
            _ds.display(ip,"ip");
            _ds.display(port,"port");
            _ds.display(isTcp,"isTcp");
            _ds.display(weight,"weight");
            _ds.display(setname,"setname");
            return _os;
        }
        std::ostream& displaySimple(std::ostream& _os, int _level=0) const
        {
            Tseerapi::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ip, true);
            _ds.displaySimple(port, true);
            _ds.displaySimple(isTcp, true);
            _ds.displaySimple(weight, true);
            _ds.displaySimple(setname, false);
            return _os;
        }
    public:
        std::string ip;
        Tseerapi::Int32 port;
        Tseerapi::Bool isTcp;
        Tseerapi::Int32 weight;
        std::string setname;
    };
    inline bool operator==(const RouterNodeInfo&l, const RouterNodeInfo&r)
    {
        return l.ip == r.ip && l.port == r.port && l.isTcp == r.isTcp && l.weight == r.weight && l.setname == r.setname;
    }
    inline bool operator!=(const RouterNodeInfo&l, const RouterNodeInfo&r)
    {
        return !(l == r);
    }
    inline bool operator<(const RouterNodeInfo&l, const RouterNodeInfo&r)
    {
        if (l.ip < r.ip) {
            return true;
        } else if (l.ip == r.ip) {
            return l.port < r.port;
        } else {
            return false;
        }
    }

    struct AgentRouterResponse : public Tseerapi::TarsStructBase
    {
    public:
        static std::string className()
        {
            return "Tseer.AgentRouterResponse";
        }
        static std::string MD5()
        {
            return "402d3dedfd73d22dfada11e882d465dc";
        }
        AgentRouterResponse()
        :getType(Tseer::GET_IDC),obj(""),setname("")
        {
        }
        void resetDefautlt()
        {
            obj = "";
            setname = "";
        }
        template<typename WriterT>
        void writeTo(Tseerapi::TarsOutputStream<WriterT>& _os) const
        {
            _os.write((Tseerapi::Int32)getType, 1);
            if (obj != "")
            {
                _os.write(obj, 2);
            }
            if (setname != "")
            {
                _os.write(setname, 3);
            }
            if (resultList.size() > 0)
            {
                _os.write(resultList, 4);
            }
        }
        template<typename ReaderT>
        void readFrom(Tseerapi::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            Tseerapi::Int32 eTemp1 = Tseer::GET_IDC;
            _is.read(eTemp1, 1, false);
            getType = (Tseer::LB_GET_TYPE)eTemp1;
            _is.read(obj, 2, false);
            _is.read(setname, 3, false);
            _is.read(resultList, 4, false);
        }
        std::ostream& display(std::ostream& _os, int _level=0) const
        {
            Tseerapi::TarsDisplayer _ds(_os, _level);
            _ds.display((Tseerapi::Int32)getType,"getType");
            _ds.display(obj,"obj");
            _ds.display(setname,"setname");
            _ds.display(resultList,"resultList");
            return _os;
        }
        std::ostream& displaySimple(std::ostream& _os, int _level=0) const
        {
            Tseerapi::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple((Tseerapi::Int32)getType, true);
            _ds.displaySimple(obj, true);
            _ds.displaySimple(setname, true);
            _ds.displaySimple(resultList, false);
            return _os;
        }
    public:
        Tseer::LB_GET_TYPE getType;
        std::string obj;
        std::string setname;
        std::vector<Tseer::RouterNodeInfo> resultList;
    };
    inline bool operator==(const AgentRouterResponse&l, const AgentRouterResponse&r)
    {
        return l.getType == r.getType && l.obj == r.obj && l.setname == r.setname && l.resultList == r.resultList;
    }
    inline bool operator!=(const AgentRouterResponse&l, const AgentRouterResponse&r)
    {
        return !(l == r);
    }

    struct NodeStat : public Tseerapi::TarsStructBase
    {
    public:
        static std::string className()
        {
            return "Tseer.NodeStat";
        }
        static std::string MD5()
        {
            return "9c8e391c0abb2b107d082c738b11b06d";
        }
        NodeStat()
        :localIp(""),timeCost(0),ret(0),moduleName(""),ip(""),port(0),obj(""),isTcp(true),setname(""),apiVer(""),lbType(Tseer::LB_TYPE_LOOP),getType(Tseer::GET_IDC),identifier("")
        {
        }
        void resetDefautlt()
        {
            localIp = "";
            timeCost = 0;
            ret = 0;
            moduleName = "";
            ip = "";
            port = 0;
            obj = "";
            isTcp = true;
            setname = "";
            apiVer = "";
            identifier = "";
        }
        template<typename WriterT>
        void writeTo(Tseerapi::TarsOutputStream<WriterT>& _os) const
        {
            if (localIp != "")
            {
                _os.write(localIp, 1);
            }
            if (timeCost != 0)
            {
                _os.write(timeCost, 2);
            }
            if (ret != 0)
            {
                _os.write(ret, 3);
            }
            if (moduleName != "")
            {
                _os.write(moduleName, 4);
            }
            if (ip != "")
            {
                _os.write(ip, 5);
            }
            if (port != 0)
            {
                _os.write(port, 6);
            }
            if (obj != "")
            {
                _os.write(obj, 7);
            }
            if (isTcp != true)
            {
                _os.write(isTcp, 8);
            }
            if (setname != "")
            {
                _os.write(setname, 9);
            }
            if (apiVer != "")
            {
                _os.write(apiVer, 10);
            }
            _os.write((Tseerapi::Int32)lbType, 11);
            _os.write((Tseerapi::Int32)getType, 12);
            if (identifier != "")
            {
                _os.write(identifier, 13);
            }
        }
        template<typename ReaderT>
        void readFrom(Tseerapi::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(localIp, 1, false);
            _is.read(timeCost, 2, false);
            _is.read(ret, 3, false);
            _is.read(moduleName, 4, false);
            _is.read(ip, 5, false);
            _is.read(port, 6, false);
            _is.read(obj, 7, false);
            _is.read(isTcp, 8, false);
            _is.read(setname, 9, false);
            _is.read(apiVer, 10, false);
            Tseerapi::Int32 eTemp11 = Tseer::LB_TYPE_LOOP;
            _is.read(eTemp11, 11, false);
            lbType = (Tseer::LB_TYPE)eTemp11;
            Tseerapi::Int32 eTemp12 = Tseer::GET_IDC;
            _is.read(eTemp12, 12, false);
            getType = (Tseer::LB_GET_TYPE)eTemp12;
            _is.read(identifier, 13, false);
        }
        std::ostream& display(std::ostream& _os, int _level=0) const
        {
            Tseerapi::TarsDisplayer _ds(_os, _level);
            _ds.display(localIp,"localIp");
            _ds.display(timeCost,"timeCost");
            _ds.display(ret,"ret");
            _ds.display(moduleName,"moduleName");
            _ds.display(ip,"ip");
            _ds.display(port,"port");
            _ds.display(obj,"obj");
            _ds.display(isTcp,"isTcp");
            _ds.display(setname,"setname");
            _ds.display(apiVer,"apiVer");
            _ds.display((Tseerapi::Int32)lbType,"lbType");
            _ds.display((Tseerapi::Int32)getType,"getType");
            _ds.display(identifier,"identifier");
            return _os;
        }
        std::ostream& displaySimple(std::ostream& _os, int _level=0) const
        {
            Tseerapi::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(localIp, true);
            _ds.displaySimple(timeCost, true);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(moduleName, true);
            _ds.displaySimple(ip, true);
            _ds.displaySimple(port, true);
            _ds.displaySimple(obj, true);
            _ds.displaySimple(isTcp, true);
            _ds.displaySimple(setname, true);
            _ds.displaySimple(apiVer, true);
            _ds.displaySimple((Tseerapi::Int32)lbType, true);
            _ds.displaySimple((Tseerapi::Int32)getType, true);
            _ds.displaySimple(identifier, false);
            return _os;
        }
    public:
        std::string localIp;
        Tseerapi::Int32 timeCost;
        Tseerapi::Int32 ret;
        std::string moduleName;
        std::string ip;
        Tseerapi::Int32 port;
        std::string obj;
        Tseerapi::Bool isTcp;
        std::string setname;
        std::string apiVer;
        Tseer::LB_TYPE lbType;
        Tseer::LB_GET_TYPE getType;
        std::string identifier;
    };
    inline bool operator==(const NodeStat&l, const NodeStat&r)
    {
        return l.localIp == r.localIp && l.timeCost == r.timeCost && l.ret == r.ret && l.moduleName == r.moduleName && l.ip == r.ip && l.port == r.port && l.obj == r.obj && l.isTcp == r.isTcp && l.setname == r.setname && l.apiVer == r.apiVer && l.lbType == r.lbType && l.getType == r.getType && l.identifier == r.identifier;
    }
    inline bool operator!=(const NodeStat&l, const NodeStat&r)
    {
        return !(l == r);
    }


}



#endif
