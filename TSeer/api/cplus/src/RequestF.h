/**
 * Tencent is pleased to support the open source community by making Tseer available.
 *
 * Copyright (C) 2018 THL A29 Limited, a Tencent company. All rights reserved.
 * 
 * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * https://opensource.org/licenses/BSD-3-Clause
 *
 * Unless required by applicable law or agreed to in writing, software distributed 
 * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 3.0.0.26 by WSRD Tencent.
// Generated from `RequestF.tars'
// **********************************************************************

#ifndef __REQUESTF_H_
#define __REQUESTF_H_

#include <map>
#include <string>
#include <vector>
#include "Tars.h"
using namespace std;


namespace Tseerapi
{
    struct RequestPacket : public Tseerapi::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.RequestPacket";
        }
        static string MD5()
        {
            return "ca2347e333175043f3ec17083b16e36d";
        }
        RequestPacket()
        :iVersion(0),cPacketType(0),iMessageType(0),iRequestId(0),sServantName(""),funcName(""),timeOut(0)
        {
        }
        void resetDefautlt()
        {
            iVersion = 0;
            cPacketType = 0;
            iMessageType = 0;
            iRequestId = 0;
            sServantName = "";
            funcName = "";
            timeOut = 0;
        }
        template<typename WriterT>
        void writeTo(Tseerapi::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(iVersion, 1);
            _os.write(cPacketType, 2);
            _os.write(iMessageType, 3);
            _os.write(iRequestId, 4);
            _os.write(sServantName, 5);
            _os.write(funcName, 6);
            _os.write(buffer, 7);
            _os.write(timeOut, 8);
            _os.write(context, 9);
            _os.write(status, 10);
        }
        template<typename ReaderT>
        void readFrom(Tseerapi::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iVersion, 1, true);
            _is.read(cPacketType, 2, true);
            _is.read(iMessageType, 3, true);
            _is.read(iRequestId, 4, true);
            _is.read(sServantName, 5, true);
            _is.read(funcName, 6, true);
            _is.read(buffer, 7, true);
            _is.read(timeOut, 8, true);
            _is.read(context, 9, true);
            _is.read(status, 10, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            Tseerapi::TarsDisplayer _ds(_os, _level);
            _ds.display(iVersion,"iVersion");
            _ds.display(cPacketType,"cPacketType");
            _ds.display(iMessageType,"iMessageType");
            _ds.display(iRequestId,"iRequestId");
            _ds.display(sServantName,"sServantName");
            _ds.display(funcName,"funcName");
            _ds.display(buffer,"buffer");
            _ds.display(timeOut,"timeOut");
            _ds.display(context,"context");
            _ds.display(status,"status");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            Tseerapi::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(iVersion, true);
            _ds.displaySimple(cPacketType, true);
            _ds.displaySimple(iMessageType, true);
            _ds.displaySimple(iRequestId, true);
            _ds.displaySimple(sServantName, true);
            _ds.displaySimple(funcName, true);
            _ds.displaySimple(buffer, true);
            _ds.displaySimple(timeOut, true);
            _ds.displaySimple(context, true);
            _ds.displaySimple(status, false);
            return _os;
        }
    public:
        Tseerapi::Short iVersion;
        Tseerapi::Char cPacketType;
        Tseerapi::Int32 iMessageType;
        Tseerapi::Int32 iRequestId;
        std::string sServantName;
        std::string funcName;
        vector<Tseerapi::Char> buffer;
        Tseerapi::Int32 timeOut;
        map<std::string, std::string> context;
        map<std::string, std::string> status;
    };
    inline bool operator==(const RequestPacket&l, const RequestPacket&r)
    {
        return l.iVersion == r.iVersion && l.cPacketType == r.cPacketType && l.iMessageType == r.iMessageType && l.iRequestId == r.iRequestId && l.sServantName == r.sServantName && l.funcName == r.funcName && l.buffer == r.buffer && l.timeOut == r.timeOut && l.context == r.context && l.status == r.status;
    }
    inline bool operator!=(const RequestPacket&l, const RequestPacket&r)
    {
        return !(l == r);
    }

    struct ResponsePacket : public Tseerapi::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.ResponsePacket";
        }
        static string MD5()
        {
            return "9a587534dfcf0c56e30b40d2493d8da7";
        }
        ResponsePacket()
        :iVersion(0),cPacketType(0),iRequestId(0),iMessageType(0),ret(0),sResultDesc("")
        {
        }
        void resetDefautlt()
        {
            iVersion = 0;
            cPacketType = 0;
            iRequestId = 0;
            iMessageType = 0;
            ret = 0;
            sResultDesc = "";
        }
        template<typename WriterT>
        void writeTo(Tseerapi::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(iVersion, 1);
            _os.write(cPacketType, 2);
            _os.write(iRequestId, 3);
            _os.write(iMessageType, 4);
            _os.write(ret, 5);
            _os.write(buffer, 6);
            _os.write(status, 7);
            _os.write(sResultDesc, 8);
            _os.write(context, 9);
        }
        template<typename ReaderT>
        void readFrom(Tseerapi::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iVersion, 1, true);
            _is.read(cPacketType, 2, true);
            _is.read(iRequestId, 3, true);
            _is.read(iMessageType, 4, true);
            _is.read(ret, 5, true);
            _is.read(buffer, 6, true);
            _is.read(status, 7, true);
            _is.read(sResultDesc, 8, false);
            _is.read(context, 9, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            Tseerapi::TarsDisplayer _ds(_os, _level);
            _ds.display(iVersion,"iVersion");
            _ds.display(cPacketType,"cPacketType");
            _ds.display(iRequestId,"iRequestId");
            _ds.display(iMessageType,"iMessageType");
            _ds.display(ret,"ret");
            _ds.display(buffer,"buffer");
            _ds.display(status,"status");
            _ds.display(sResultDesc,"sResultDesc");
            _ds.display(context,"context");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            Tseerapi::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(iVersion, true);
            _ds.displaySimple(cPacketType, true);
            _ds.displaySimple(iRequestId, true);
            _ds.displaySimple(iMessageType, true);
            _ds.displaySimple(ret, true);
            _ds.displaySimple(buffer, true);
            _ds.displaySimple(status, true);
            _ds.displaySimple(sResultDesc, true);
            _ds.displaySimple(context, false);
            return _os;
        }
    public:
        Tseerapi::Short iVersion;
        Tseerapi::Char cPacketType;
        Tseerapi::Int32 iRequestId;
        Tseerapi::Int32 iMessageType;
        Tseerapi::Int32 ret;
        vector<Tseerapi::Char> buffer;
        map<std::string, std::string> status;
        std::string sResultDesc;
        map<std::string, std::string> context;
    };
    inline bool operator==(const ResponsePacket&l, const ResponsePacket&r)
    {
        return l.iVersion == r.iVersion && l.cPacketType == r.cPacketType && l.iRequestId == r.iRequestId && l.iMessageType == r.iMessageType && l.ret == r.ret && l.buffer == r.buffer && l.status == r.status && l.sResultDesc == r.sResultDesc && l.context == r.context;
    }
    inline bool operator!=(const ResponsePacket&l, const ResponsePacket&r)
    {
        return !(l == r);
    }


}

#define tars_RequestPacket_TARS_COPY_STRUCT_HELPER   \
        tars_copy_struct(a.iVersion,b.iVersion);tars_copy_struct(a.cPacketType,b.cPacketType);tars_copy_struct(a.iMessageType,b.iMessageType);tars_copy_struct(a.iRequestId,b.iRequestId);tars_copy_struct(a.sServantName,b.sServantName);tars_copy_struct(a.funcName,b.funcName);tars_copy_struct(a.buffer,b.buffer);tars_copy_struct(a.timeOut,b.timeOut);tars_copy_struct(a.context,b.context);tars_copy_struct(a.status,b.status);

#define tars_ResponsePacket_TARS_COPY_STRUCT_HELPER   \
        tars_copy_struct(a.iVersion,b.iVersion);tars_copy_struct(a.cPacketType,b.cPacketType);tars_copy_struct(a.iRequestId,b.iRequestId);tars_copy_struct(a.iMessageType,b.iMessageType);tars_copy_struct(a.ret,b.ret);tars_copy_struct(a.buffer,b.buffer);tars_copy_struct(a.status,b.status);tars_copy_struct(a.sResultDesc,b.sResultDesc);tars_copy_struct(a.context,b.context);



#endif
