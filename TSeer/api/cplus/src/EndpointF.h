/**
 * Tencent is pleased to support the open source community by making Tseer available.
 *
 * Copyright (C) 2018 THL A29 Limited, a Tencent company. All rights reserved.
 * 
 * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * https://opensource.org/licenses/BSD-3-Clause
 *
 * Unless required by applicable law or agreed to in writing, software distributed 
 * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 3.2.2.3 by WSRD Tencent.
// Generated from `EndpointF.tars'
// **********************************************************************

#ifndef __ENDPOINTF_H_
#define __ENDPOINTF_H_

#include <map>
#include <string>
#include <vector>
#include "Tars.h"

//更改命名空间 tars -> Tseerapiapi
namespace Tseerapi
{
    struct EndpointF : public Tseerapi::TarsStructBase
    {
    public:
        static std::string className()
        {
            return "tars.EndpointF";
        }
        static std::string MD5()
        {
            return "af237597478b8af4c34fe0a15a91584c";
        }
        EndpointF()
        :host(""),port(0),timeout(0),istcp(0),grid(0),groupworkid(0),grouprealid(0),setId(""),qos(0),bakFlag(0),gridFlag(0),weight(0),weightType(0),cpuload(0),sampletime(0),containerName("")
        {
        }
        void resetDefautlt()
        {
            host = "";
            port = 0;
            timeout = 0;
            istcp = 0;
            grid = 0;
            groupworkid = 0;
            grouprealid = 0;
            setId = "";
            qos = 0;
            bakFlag = 0;
            gridFlag = 0;
            weight = 0;
            weightType = 0;
            cpuload = 0;
            sampletime = 0;
            containerName = "";
        }
        template<typename WriterT>
        void writeTo(Tseerapi::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(host, 0);
            _os.write(port, 1);
            _os.write(timeout, 2);
            _os.write(istcp, 3);
            _os.write(grid, 4);
            _os.write(groupworkid, 5);
            _os.write(grouprealid, 6);
            _os.write(setId, 7);
            _os.write(qos, 8);
            _os.write(bakFlag, 9);
            _os.write(gridFlag, 10);
            _os.write(weight, 11);
            _os.write(weightType, 12);
            _os.write(cpuload, 13);
            _os.write(sampletime, 14);
            _os.write(containerName, 15);
        }
        template<typename ReaderT>
        void readFrom(Tseerapi::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(host, 0, true);
            _is.read(port, 1, true);
            _is.read(timeout, 2, true);
            _is.read(istcp, 3, true);
            _is.read(grid, 4, true);
            _is.read(groupworkid, 5, false);
            _is.read(grouprealid, 6, false);
            _is.read(setId, 7, false);
            _is.read(qos, 8, false);
            _is.read(bakFlag, 9, false);
            _is.read(gridFlag, 10, false);
            _is.read(weight, 11, false);
            _is.read(weightType, 12, false);
            _is.read(cpuload, 13, false);
            _is.read(sampletime, 14, false);
            _is.read(containerName, 15, false);
        }
        std::ostream& display(std::ostream& _os, int _level=0) const
        {
            Tseerapi::TarsDisplayer _ds(_os, _level);
            _ds.display(host,"host");
            _ds.display(port,"port");
            _ds.display(timeout,"timeout");
            _ds.display(istcp,"istcp");
            _ds.display(grid,"grid");
            _ds.display(groupworkid,"groupworkid");
            _ds.display(grouprealid,"grouprealid");
            _ds.display(setId,"setId");
            _ds.display(qos,"qos");
            _ds.display(bakFlag,"bakFlag");
            _ds.display(gridFlag,"gridFlag");
            _ds.display(weight,"weight");
            _ds.display(weightType,"weightType");
            _ds.display(cpuload,"cpuload");
            _ds.display(sampletime,"sampletime");
            _ds.display(containerName,"containerName");
            return _os;
        }
        std::ostream& displaySimple(std::ostream& _os, int _level=0) const
        {
            Tseerapi::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(host, true);
            _ds.displaySimple(port, true);
            _ds.displaySimple(timeout, true);
            _ds.displaySimple(istcp, true);
            _ds.displaySimple(grid, true);
            _ds.displaySimple(groupworkid, true);
            _ds.displaySimple(grouprealid, true);
            _ds.displaySimple(setId, true);
            _ds.displaySimple(qos, true);
            _ds.displaySimple(bakFlag, true);
            _ds.displaySimple(gridFlag, true);
            _ds.displaySimple(weight, true);
            _ds.displaySimple(weightType, true);
            _ds.displaySimple(cpuload, true);
            _ds.displaySimple(sampletime, true);
            _ds.displaySimple(containerName, false);
            return _os;
        }
    public:
        std::string host;
        Tseerapi::Int32 port;
        Tseerapi::Int32 timeout;
        Tseerapi::Int32 istcp;
        Tseerapi::Int32 grid;
        Tseerapi::Int32 groupworkid;
        Tseerapi::Int32 grouprealid;
        std::string setId;
        Tseerapi::Int32 qos;
        Tseerapi::Int32 bakFlag;
        Tseerapi::Int32 gridFlag;
        Tseerapi::Int32 weight;
        Tseerapi::Int32 weightType;
        Tseerapi::Int32 cpuload;
        Tseerapi::Int64 sampletime;
        std::string containerName;
    };
    inline bool operator==(const EndpointF&l, const EndpointF&r)
    {
        return l.host == r.host && l.port == r.port && l.timeout == r.timeout && l.istcp == r.istcp && l.grid == r.grid && l.groupworkid == r.groupworkid && l.grouprealid == r.grouprealid && l.setId == r.setId && l.qos == r.qos && l.bakFlag == r.bakFlag && l.gridFlag == r.gridFlag && l.weight == r.weight && l.weightType == r.weightType && l.cpuload == r.cpuload && l.sampletime == r.sampletime && l.containerName == r.containerName;
    }
    inline bool operator!=(const EndpointF&l, const EndpointF&r)
    {
        return !(l == r);
    }
    inline bool operator<(const EndpointF&l, const EndpointF&r)
    {
        if(l.host != r.host)  return (l.host < r.host);
        if(l.port != r.port)  return (l.port < r.port);
        if(l.timeout != r.timeout)  return (l.timeout < r.timeout);
        if(l.istcp != r.istcp)  return (l.istcp < r.istcp);
        if(l.grid != r.grid)  return (l.grid < r.grid);
        if(l.qos != r.qos)  return (l.qos < r.qos);
        if(l.gridFlag != r.gridFlag)  return (l.gridFlag < r.gridFlag);
        if(l.weight != r.weight)  return (l.weight < r.weight);
        if(l.weightType != r.weightType)  return (l.weightType < r.weightType);
        return false;
    }
    inline bool operator<=(const EndpointF&l, const EndpointF&r)
    {
        return !(r < l);
    }
    inline bool operator>(const EndpointF&l, const EndpointF&r)
    {
        return r < l;
    }
    inline bool operator>=(const EndpointF&l, const EndpointF&r)
    {
        return !(l < r);
    }


}

#define tars_EndpointF_TARS_COPY_STRUCT_HELPER   \
        tars_copy_struct(a.host,b.host);tars_copy_struct(a.port,b.port);tars_copy_struct(a.timeout,b.timeout);tars_copy_struct(a.istcp,b.istcp);tars_copy_struct(a.grid,b.grid);tars_copy_struct(a.groupworkid,b.groupworkid);tars_copy_struct(a.grouprealid,b.grouprealid);tars_copy_struct(a.setId,b.setId);tars_copy_struct(a.qos,b.qos);tars_copy_struct(a.bakFlag,b.bakFlag);tars_copy_struct(a.gridFlag,b.gridFlag);tars_copy_struct(a.weight,b.weight);tars_copy_struct(a.weightType,b.weightType);tars_copy_struct(a.cpuload,b.cpuload);tars_copy_struct(a.sampletime,b.sampletime);tars_copy_struct(a.containerName,b.containerName);



#endif
