// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 1.1.0.
// **********************************************************************

#ifndef __REGISTRYDESCRIPTOR_H_
#define __REGISTRYDESCRIPTOR_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
using namespace std;
#include "QueryF.h"


namespace Tseer
{
    enum ServerState
    {
        Inactive,
        Activating,
        Active,
        Deactivating,
        Destroying,
        Destroyed,
    };
    inline string etos(const ServerState & e)
    {
        switch(e)
        {
            case Inactive: return "Inactive";
            case Activating: return "Activating";
            case Active: return "Active";
            case Deactivating: return "Deactivating";
            case Destroying: return "Destroying";
            case Destroyed: return "Destroyed";
            default: return "";
        }
    }
    inline int stoe(const string & s, ServerState & e)
    {
        if(s == "Inactive")  { e=Inactive; return 0;}
        if(s == "Activating")  { e=Activating; return 0;}
        if(s == "Active")  { e=Active; return 0;}
        if(s == "Deactivating")  { e=Deactivating; return 0;}
        if(s == "Destroying")  { e=Destroying; return 0;}
        if(s == "Destroyed")  { e=Destroyed; return 0;}

        return -1;
    }

    struct AdapterDescriptor : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Tseer.AdapterDescriptor";
        }
        static string MD5()
        {
            return "9e3cb7561132fa353124ecbcf3edf4c0";
        }
        AdapterDescriptor()
        :adapterName(""),threadNum(""),endpoint(""),maxConnections(0),allowIp(""),servant(""),queuecap(0),queuetimeout(0),protocol(""),handlegroup(""),shmkey(0),shmcap(0)
        {
        }
        void resetDefautlt()
        {
            adapterName = "";
            threadNum = "";
            endpoint = "";
            maxConnections = 0;
            allowIp = "";
            servant = "";
            queuecap = 0;
            queuetimeout = 0;
            protocol = "";
            handlegroup = "";
            shmkey = 0;
            shmcap = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(adapterName, 0);
            _os.write(threadNum, 1);
            _os.write(endpoint, 2);
            _os.write(maxConnections, 3);
            _os.write(allowIp, 4);
            _os.write(servant, 5);
            _os.write(queuecap, 6);
            _os.write(queuetimeout, 7);
            if (protocol != "")
            {
                _os.write(protocol, 9);
            }
            if (handlegroup != "")
            {
                _os.write(handlegroup, 10);
            }
            if (shmkey != 0)
            {
                _os.write(shmkey, 11);
            }
            if (shmcap != 0)
            {
                _os.write(shmcap, 12);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(adapterName, 0, true);
            _is.read(threadNum, 1, true);
            _is.read(endpoint, 2, true);
            _is.read(maxConnections, 3, true);
            _is.read(allowIp, 4, true);
            _is.read(servant, 5, true);
            _is.read(queuecap, 6, true);
            _is.read(queuetimeout, 7, true);
            _is.read(protocol, 9, false);
            _is.read(handlegroup, 10, false);
            _is.read(shmkey, 11, false);
            _is.read(shmcap, 12, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(adapterName,"adapterName");
            _ds.display(threadNum,"threadNum");
            _ds.display(endpoint,"endpoint");
            _ds.display(maxConnections,"maxConnections");
            _ds.display(allowIp,"allowIp");
            _ds.display(servant,"servant");
            _ds.display(queuecap,"queuecap");
            _ds.display(queuetimeout,"queuetimeout");
            _ds.display(protocol,"protocol");
            _ds.display(handlegroup,"handlegroup");
            _ds.display(shmkey,"shmkey");
            _ds.display(shmcap,"shmcap");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(adapterName, true);
            _ds.displaySimple(threadNum, true);
            _ds.displaySimple(endpoint, true);
            _ds.displaySimple(maxConnections, true);
            _ds.displaySimple(allowIp, true);
            _ds.displaySimple(servant, true);
            _ds.displaySimple(queuecap, true);
            _ds.displaySimple(queuetimeout, true);
            _ds.displaySimple(protocol, true);
            _ds.displaySimple(handlegroup, true);
            _ds.displaySimple(shmkey, true);
            _ds.displaySimple(shmcap, false);
            return _os;
        }
    public:
        std::string adapterName;
        std::string threadNum;
        std::string endpoint;
        tars::Int32 maxConnections;
        std::string allowIp;
        std::string servant;
        tars::Int32 queuecap;
        tars::Int32 queuetimeout;
        std::string protocol;
        std::string handlegroup;
        tars::Int32 shmkey;
        tars::Int32 shmcap;
    };
    inline bool operator==(const AdapterDescriptor&l, const AdapterDescriptor&r)
    {
        return l.adapterName == r.adapterName && l.threadNum == r.threadNum && l.endpoint == r.endpoint && l.maxConnections == r.maxConnections && l.allowIp == r.allowIp && l.servant == r.servant && l.queuecap == r.queuecap && l.queuetimeout == r.queuetimeout && l.protocol == r.protocol && l.handlegroup == r.handlegroup && l.shmkey == r.shmkey && l.shmcap == r.shmcap;
    }
    inline bool operator!=(const AdapterDescriptor&l, const AdapterDescriptor&r)
    {
        return !(l == r);
    }

    struct ServerDescriptor : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Tseer.ServerDescriptor";
        }
        static string MD5()
        {
            return "2310db6c48e36d2d0b2a417402ec210d";
        }
        ServerDescriptor()
        :application(""),serverName(""),nodeName(""),basePath(""),exePath(""),settingState(""),presentState(""),profile(""),patchVersion(""),patchTime(""),patchUser(""),serverType(""),startScript(""),stopScript(""),monitorScript(""),configCenterPort(0),asyncThreadNum(0),setId("")
        {
        }
        void resetDefautlt()
        {
            application = "";
            serverName = "";
            nodeName = "";
            basePath = "";
            exePath = "";
            settingState = "";
            presentState = "";
            profile = "";
            patchVersion = "";
            patchTime = "";
            patchUser = "";
            serverType = "";
            startScript = "";
            stopScript = "";
            monitorScript = "";
            configCenterPort = 0;
            asyncThreadNum = 0;
            setId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(application, 0);
            _os.write(serverName, 1);
            _os.write(nodeName, 2);
            _os.write(basePath, 3);
            _os.write(exePath, 4);
            _os.write(settingState, 5);
            _os.write(presentState, 6);
            _os.write(profile, 7);
            _os.write(patchVersion, 8);
            _os.write(patchTime, 9);
            _os.write(patchUser, 10);
            _os.write(adapters, 11);
            if (serverType != "")
            {
                _os.write(serverType, 12);
            }
            if (startScript != "")
            {
                _os.write(startScript, 13);
            }
            if (stopScript != "")
            {
                _os.write(stopScript, 14);
            }
            if (monitorScript != "")
            {
                _os.write(monitorScript, 15);
            }
            if (configCenterPort != 0)
            {
                _os.write(configCenterPort, 16);
            }
            if (asyncThreadNum != 0)
            {
                _os.write(asyncThreadNum, 17);
            }
            if (setId != "")
            {
                _os.write(setId, 18);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(application, 0, true);
            _is.read(serverName, 1, true);
            _is.read(nodeName, 2, true);
            _is.read(basePath, 3, true);
            _is.read(exePath, 4, true);
            _is.read(settingState, 5, true);
            _is.read(presentState, 6, true);
            _is.read(profile, 7, true);
            _is.read(patchVersion, 8, true);
            _is.read(patchTime, 9, true);
            _is.read(patchUser, 10, true);
            _is.read(adapters, 11, true);
            _is.read(serverType, 12, false);
            _is.read(startScript, 13, false);
            _is.read(stopScript, 14, false);
            _is.read(monitorScript, 15, false);
            _is.read(configCenterPort, 16, false);
            _is.read(asyncThreadNum, 17, false);
            _is.read(setId, 18, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(application,"application");
            _ds.display(serverName,"serverName");
            _ds.display(nodeName,"nodeName");
            _ds.display(basePath,"basePath");
            _ds.display(exePath,"exePath");
            _ds.display(settingState,"settingState");
            _ds.display(presentState,"presentState");
            _ds.display(profile,"profile");
            _ds.display(patchVersion,"patchVersion");
            _ds.display(patchTime,"patchTime");
            _ds.display(patchUser,"patchUser");
            _ds.display(adapters,"adapters");
            _ds.display(serverType,"serverType");
            _ds.display(startScript,"startScript");
            _ds.display(stopScript,"stopScript");
            _ds.display(monitorScript,"monitorScript");
            _ds.display(configCenterPort,"configCenterPort");
            _ds.display(asyncThreadNum,"asyncThreadNum");
            _ds.display(setId,"setId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(application, true);
            _ds.displaySimple(serverName, true);
            _ds.displaySimple(nodeName, true);
            _ds.displaySimple(basePath, true);
            _ds.displaySimple(exePath, true);
            _ds.displaySimple(settingState, true);
            _ds.displaySimple(presentState, true);
            _ds.displaySimple(profile, true);
            _ds.displaySimple(patchVersion, true);
            _ds.displaySimple(patchTime, true);
            _ds.displaySimple(patchUser, true);
            _ds.displaySimple(adapters, true);
            _ds.displaySimple(serverType, true);
            _ds.displaySimple(startScript, true);
            _ds.displaySimple(stopScript, true);
            _ds.displaySimple(monitorScript, true);
            _ds.displaySimple(configCenterPort, true);
            _ds.displaySimple(asyncThreadNum, true);
            _ds.displaySimple(setId, false);
            return _os;
        }
    public:
        std::string application;
        std::string serverName;
        std::string nodeName;
        std::string basePath;
        std::string exePath;
        std::string settingState;
        std::string presentState;
        std::string profile;
        std::string patchVersion;
        std::string patchTime;
        std::string patchUser;
        map<std::string, Tseer::AdapterDescriptor> adapters;
        std::string serverType;
        std::string startScript;
        std::string stopScript;
        std::string monitorScript;
        tars::Int32 configCenterPort;
        tars::Int32 asyncThreadNum;
        std::string setId;
    };
    inline bool operator==(const ServerDescriptor&l, const ServerDescriptor&r)
    {
        return l.application == r.application && l.serverName == r.serverName && l.nodeName == r.nodeName && l.basePath == r.basePath && l.exePath == r.exePath && l.settingState == r.settingState && l.presentState == r.presentState && l.profile == r.profile && l.patchVersion == r.patchVersion && l.patchTime == r.patchTime && l.patchUser == r.patchUser && l.adapters == r.adapters && l.serverType == r.serverType && l.startScript == r.startScript && l.stopScript == r.stopScript && l.monitorScript == r.monitorScript && l.configCenterPort == r.configCenterPort && l.asyncThreadNum == r.asyncThreadNum && l.setId == r.setId;
    }
    inline bool operator!=(const ServerDescriptor&l, const ServerDescriptor&r)
    {
        return !(l == r);
    }

    struct ObjectName : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Tseer.ObjectName";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        ObjectName()
        :ObjectId("")
        {
        }
        void resetDefautlt()
        {
            ObjectId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(ObjectId, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ObjectId, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ObjectId,"ObjectId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ObjectId, false);
            return _os;
        }
    public:
        std::string ObjectId;
    };
    inline bool operator==(const ObjectName&l, const ObjectName&r)
    {
        return l.ObjectId == r.ObjectId;
    }
    inline bool operator!=(const ObjectName&l, const ObjectName&r)
    {
        return !(l == r);
    }

    struct ObjectItem : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Tseer.ObjectItem";
        }
        static string MD5()
        {
            return "a9b5b6e307adadbdd5ed2c2e9ce975b9";
        }
        ObjectItem()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(vActiveEndpoints, 0);
            _os.write(vInactiveEndpoints, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(vActiveEndpoints, 0, true);
            _is.read(vInactiveEndpoints, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(vActiveEndpoints,"vActiveEndpoints");
            _ds.display(vInactiveEndpoints,"vInactiveEndpoints");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(vActiveEndpoints, true);
            _ds.displaySimple(vInactiveEndpoints, false);
            return _os;
        }
    public:
        vector<Tseer::EndpointF> vActiveEndpoints;
        vector<Tseer::EndpointF> vInactiveEndpoints;
    };
    inline bool operator==(const ObjectItem&l, const ObjectItem&r)
    {
        return l.vActiveEndpoints == r.vActiveEndpoints && l.vInactiveEndpoints == r.vInactiveEndpoints;
    }
    inline bool operator!=(const ObjectItem&l, const ObjectItem&r)
    {
        return !(l == r);
    }

    struct ServerGroupRule : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Tseer.ServerGroupRule";
        }
        static string MD5()
        {
            return "b4bfec89a82e67997930a31642bacca1";
        }
        ServerGroupRule()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(vGroupRuleInfo, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(vGroupRuleInfo, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(vGroupRuleInfo,"vGroupRuleInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(vGroupRuleInfo, false);
            return _os;
        }
    public:
        vector<map<std::string, std::string> > vGroupRuleInfo;
    };
    inline bool operator==(const ServerGroupRule&l, const ServerGroupRule&r)
    {
        return l.vGroupRuleInfo == r.vGroupRuleInfo;
    }
    inline bool operator!=(const ServerGroupRule&l, const ServerGroupRule&r)
    {
        return !(l == r);
    }

    struct PackageInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Tseer.PackageInfo";
        }
        static string MD5()
        {
            return "ed5d2e90963962a81d61516eb944ffd0";
        }
        PackageInfo()
        :version(""),md5(""),packageName(""),ostype(""),netID(""),ip(""),gray(false)
        {
        }
        void resetDefautlt()
        {
            version = "";
            md5 = "";
            packageName = "";
            ostype = "";
            netID = "";
            ip = "";
            gray = false;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(version, 0);
            _os.write(md5, 1);
            _os.write(packageName, 2);
            _os.write(ostype, 3);
            _os.write(netID, 4);
            _os.write(ip, 5);
            _os.write(gray, 6);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(version, 0, true);
            _is.read(md5, 1, true);
            _is.read(packageName, 2, true);
            _is.read(ostype, 3, true);
            _is.read(netID, 4, true);
            _is.read(ip, 5, true);
            _is.read(gray, 6, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(version,"version");
            _ds.display(md5,"md5");
            _ds.display(packageName,"packageName");
            _ds.display(ostype,"ostype");
            _ds.display(netID,"netID");
            _ds.display(ip,"ip");
            _ds.display(gray,"gray");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(version, true);
            _ds.displaySimple(md5, true);
            _ds.displaySimple(packageName, true);
            _ds.displaySimple(ostype, true);
            _ds.displaySimple(netID, true);
            _ds.displaySimple(ip, true);
            _ds.displaySimple(gray, false);
            return _os;
        }
    public:
        std::string version;
        std::string md5;
        std::string packageName;
        std::string ostype;
        std::string netID;
        std::string ip;
        tars::Bool gray;
    };
    inline bool operator==(const PackageInfo&l, const PackageInfo&r)
    {
        return l.version == r.version && l.md5 == r.md5 && l.packageName == r.packageName && l.ostype == r.ostype && l.netID == r.netID && l.ip == r.ip && l.gray == r.gray;
    }
    inline bool operator!=(const PackageInfo&l, const PackageInfo&r)
    {
        return !(l == r);
    }

    struct UpdateReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Tseer.UpdateReq";
        }
        static string MD5()
        {
            return "56132fe38cae2af2a74766eba129f9a3";
        }
        UpdateReq()
        :version(""),offset(0),packageName(""),ostype(""),gray(true),netID(""),ip("")
        {
        }
        void resetDefautlt()
        {
            version = "";
            offset = 0;
            packageName = "";
            ostype = "";
            gray = true;
            netID = "";
            ip = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(version, 0);
            _os.write(offset, 1);
            _os.write(packageName, 2);
            _os.write(ostype, 3);
            _os.write(gray, 4);
            if (netID != "")
            {
                _os.write(netID, 5);
            }
            if (ip != "")
            {
                _os.write(ip, 6);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(version, 0, true);
            _is.read(offset, 1, true);
            _is.read(packageName, 2, true);
            _is.read(ostype, 3, true);
            _is.read(gray, 4, true);
            _is.read(netID, 5, false);
            _is.read(ip, 6, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(version,"version");
            _ds.display(offset,"offset");
            _ds.display(packageName,"packageName");
            _ds.display(ostype,"ostype");
            _ds.display(gray,"gray");
            _ds.display(netID,"netID");
            _ds.display(ip,"ip");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(version, true);
            _ds.displaySimple(offset, true);
            _ds.displaySimple(packageName, true);
            _ds.displaySimple(ostype, true);
            _ds.displaySimple(gray, true);
            _ds.displaySimple(netID, true);
            _ds.displaySimple(ip, false);
            return _os;
        }
    public:
        std::string version;
        tars::Int32 offset;
        std::string packageName;
        std::string ostype;
        tars::Bool gray;
        std::string netID;
        std::string ip;
    };
    inline bool operator==(const UpdateReq&l, const UpdateReq&r)
    {
        return l.version == r.version && l.offset == r.offset && l.packageName == r.packageName && l.ostype == r.ostype && l.gray == r.gray && l.netID == r.netID && l.ip == r.ip;
    }
    inline bool operator!=(const UpdateReq&l, const UpdateReq&r)
    {
        return !(l == r);
    }

    struct UpdateRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Tseer.UpdateRsp";
        }
        static string MD5()
        {
            return "f8662c07406f9fe88af4a08ae090975c";
        }
        UpdateRsp()
        :finish(true),offset(0),buff(""),packageName(""),needChange(false)
        {
        }
        void resetDefautlt()
        {
            finish = true;
            offset = 0;
            buff = "";
            packageName = "";
            needChange = false;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(finish, 0);
            _os.write(offset, 1);
            _os.write(buff, 2);
            _os.write(packageName, 3);
            if (needChange != false)
            {
                _os.write(needChange, 4);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(finish, 0, true);
            _is.read(offset, 1, true);
            _is.read(buff, 2, true);
            _is.read(packageName, 3, true);
            _is.read(needChange, 4, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(finish,"finish");
            _ds.display(offset,"offset");
            _ds.display(buff,"buff");
            _ds.display(packageName,"packageName");
            _ds.display(needChange,"needChange");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(finish, true);
            _ds.displaySimple(offset, true);
            _ds.displaySimple(buff, true);
            _ds.displaySimple(packageName, true);
            _ds.displaySimple(needChange, false);
            return _os;
        }
    public:
        tars::Bool finish;
        tars::Int32 offset;
        std::string buff;
        std::string packageName;
        tars::Bool needChange;
    };
    inline bool operator==(const UpdateRsp&l, const UpdateRsp&r)
    {
        return l.finish == r.finish && l.offset == r.offset && l.buff == r.buff && l.packageName == r.packageName && l.needChange == r.needChange;
    }
    inline bool operator!=(const UpdateRsp&l, const UpdateRsp&r)
    {
        return !(l == r);
    }

    struct PushPackageInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Tseer.PushPackageInfo";
        }
        static string MD5()
        {
            return "273c77db4860f13ddfe5396241ec4c32";
        }
        PushPackageInfo()
        :packageName(""),size(0),md5(""),pos(0),version(""),ostype("CentOs-6.5-64"),package_type(0),user("")
        {
        }
        void resetDefautlt()
        {
            packageName = "";
            size = 0;
            md5 = "";
            pos = 0;
            version = "";
            ostype = "CentOs-6.5-64";
            package_type = 0;
            user = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(packageName, 0);
            _os.write(size, 1);
            _os.write(md5, 2);
            _os.write(vb, 3);
            _os.write(pos, 4);
            if (version != "")
            {
                _os.write(version, 5);
            }
            if (ostype != "CentOs-6.5-64")
            {
                _os.write(ostype, 6);
            }
            if (package_type != 0)
            {
                _os.write(package_type, 7);
            }
            if (user != "")
            {
                _os.write(user, 9);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(packageName, 0, true);
            _is.read(size, 1, true);
            _is.read(md5, 2, true);
            _is.read(vb, 3, true);
            _is.read(pos, 4, true);
            _is.read(version, 5, false);
            _is.read(ostype, 6, false);
            _is.read(package_type, 7, false);
            _is.read(user, 9, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(packageName,"packageName");
            _ds.display(size,"size");
            _ds.display(md5,"md5");
            _ds.display(vb,"vb");
            _ds.display(pos,"pos");
            _ds.display(version,"version");
            _ds.display(ostype,"ostype");
            _ds.display(package_type,"package_type");
            _ds.display(user,"user");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(packageName, true);
            _ds.displaySimple(size, true);
            _ds.displaySimple(md5, true);
            _ds.displaySimple(vb, true);
            _ds.displaySimple(pos, true);
            _ds.displaySimple(version, true);
            _ds.displaySimple(ostype, true);
            _ds.displaySimple(package_type, true);
            _ds.displaySimple(user, false);
            return _os;
        }
    public:
        std::string packageName;
        tars::Int64 size;
        std::string md5;
        vector<tars::Char> vb;
        tars::Int64 pos;
        std::string version;
        std::string ostype;
        tars::Int32 package_type;
        std::string user;
    };
    inline bool operator==(const PushPackageInfo&l, const PushPackageInfo&r)
    {
        return l.packageName == r.packageName && l.size == r.size && l.md5 == r.md5 && l.vb == r.vb && l.pos == r.pos && l.version == r.version && l.ostype == r.ostype && l.package_type == r.package_type && l.user == r.user;
    }
    inline bool operator!=(const PushPackageInfo&l, const PushPackageInfo&r)
    {
        return !(l == r);
    }

    struct LoadInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Tseer.LoadInfo";
        }
        static string MD5()
        {
            return "51ba7d6564ede253c29d5a3399944a1b";
        }
        LoadInfo()
        :avg1(0),avg5(0),avg15(0),avgCpu(0)
        {
        }
        void resetDefautlt()
        {
            avg1 = 0;
            avg5 = 0;
            avg15 = 0;
            avgCpu = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(avg1, 0);
            _os.write(avg5, 1);
            _os.write(avg15, 2);
            if (avgCpu != 0)
            {
                _os.write(avgCpu, 3);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(avg1, 0, true);
            _is.read(avg5, 1, true);
            _is.read(avg15, 2, true);
            _is.read(avgCpu, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(avg1,"avg1");
            _ds.display(avg5,"avg5");
            _ds.display(avg15,"avg15");
            _ds.display(avgCpu,"avgCpu");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(avg1, true);
            _ds.displaySimple(avg5, true);
            _ds.displaySimple(avg15, true);
            _ds.displaySimple(avgCpu, false);
            return _os;
        }
    public:
        tars::Float avg1;
        tars::Float avg5;
        tars::Float avg15;
        tars::Int32 avgCpu;
    };
    inline bool operator==(const LoadInfo&l, const LoadInfo&r)
    {
        return l.avg1 == r.avg1 && l.avg5 == r.avg5 && l.avg15 == r.avg15 && l.avgCpu == r.avgCpu;
    }
    inline bool operator!=(const LoadInfo&l, const LoadInfo&r)
    {
        return !(l == r);
    }

    struct NodeInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Tseer.NodeInfo";
        }
        static string MD5()
        {
            return "c5e5b3311ee566ee3cdc05adeb2846a6";
        }
        NodeInfo()
        :nodeName(""),nodeObj(""),endpointIp(""),endpointPort(0),timeOut(0),dataDir(""),version(""),coreFileSize(""),openFiles(0),cpu_num(0),cpu_hz(0),memory_size(0),docker_node_version(0)
        {
        }
        void resetDefautlt()
        {
            nodeName = "";
            nodeObj = "";
            endpointIp = "";
            endpointPort = 0;
            timeOut = 0;
            dataDir = "";
            version = "";
            coreFileSize = "";
            openFiles = 0;
            cpu_num = 0;
            cpu_hz = 0;
            memory_size = 0;
            docker_node_version = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(nodeName, 0);
            _os.write(nodeObj, 1);
            _os.write(endpointIp, 2);
            _os.write(endpointPort, 3);
            _os.write(timeOut, 4);
            _os.write(dataDir, 5);
            if (version != "")
            {
                _os.write(version, 6);
            }
            if (coreFileSize != "")
            {
                _os.write(coreFileSize, 7);
            }
            if (openFiles != 0)
            {
                _os.write(openFiles, 8);
            }
            _os.write(cpu_num, 9);
            _os.write(cpu_hz, 10);
            _os.write(memory_size, 11);
            _os.write(docker_node_version, 12);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(nodeName, 0, true);
            _is.read(nodeObj, 1, true);
            _is.read(endpointIp, 2, true);
            _is.read(endpointPort, 3, true);
            _is.read(timeOut, 4, true);
            _is.read(dataDir, 5, true);
            _is.read(version, 6, false);
            _is.read(coreFileSize, 7, false);
            _is.read(openFiles, 8, false);
            _is.read(cpu_num, 9, true);
            _is.read(cpu_hz, 10, true);
            _is.read(memory_size, 11, true);
            _is.read(docker_node_version, 12, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(nodeName,"nodeName");
            _ds.display(nodeObj,"nodeObj");
            _ds.display(endpointIp,"endpointIp");
            _ds.display(endpointPort,"endpointPort");
            _ds.display(timeOut,"timeOut");
            _ds.display(dataDir,"dataDir");
            _ds.display(version,"version");
            _ds.display(coreFileSize,"coreFileSize");
            _ds.display(openFiles,"openFiles");
            _ds.display(cpu_num,"cpu_num");
            _ds.display(cpu_hz,"cpu_hz");
            _ds.display(memory_size,"memory_size");
            _ds.display(docker_node_version,"docker_node_version");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(nodeName, true);
            _ds.displaySimple(nodeObj, true);
            _ds.displaySimple(endpointIp, true);
            _ds.displaySimple(endpointPort, true);
            _ds.displaySimple(timeOut, true);
            _ds.displaySimple(dataDir, true);
            _ds.displaySimple(version, true);
            _ds.displaySimple(coreFileSize, true);
            _ds.displaySimple(openFiles, true);
            _ds.displaySimple(cpu_num, true);
            _ds.displaySimple(cpu_hz, true);
            _ds.displaySimple(memory_size, true);
            _ds.displaySimple(docker_node_version, false);
            return _os;
        }
    public:
        std::string nodeName;
        std::string nodeObj;
        std::string endpointIp;
        tars::Int32 endpointPort;
        tars::Short timeOut;
        std::string dataDir;
        std::string version;
        std::string coreFileSize;
        tars::Int32 openFiles;
        tars::Int32 cpu_num;
        tars::Int32 cpu_hz;
        tars::Int64 memory_size;
        tars::Int32 docker_node_version;
    };
    inline bool operator==(const NodeInfo&l, const NodeInfo&r)
    {
        return l.nodeName == r.nodeName && l.nodeObj == r.nodeObj && l.endpointIp == r.endpointIp && l.endpointPort == r.endpointPort && l.timeOut == r.timeOut && l.dataDir == r.dataDir && l.version == r.version && l.coreFileSize == r.coreFileSize && l.openFiles == r.openFiles && l.cpu_num == r.cpu_num && l.cpu_hz == r.cpu_hz && l.memory_size == r.memory_size && l.docker_node_version == r.docker_node_version;
    }
    inline bool operator!=(const NodeInfo&l, const NodeInfo&r)
    {
        return !(l == r);
    }

    struct NodeInstanceInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Tseer.NodeInstanceInfo";
        }
        static string MD5()
        {
            return "26a898b86ec52b208c13f81a9242fcd3";
        }
        NodeInstanceInfo()
        :nodeName(""),nodeObj(""),endpointIp(""),endpointPort(0),version(""),osversion(""),locator("")
        {
        }
        void resetDefautlt()
        {
            nodeName = "";
            nodeObj = "";
            endpointIp = "";
            endpointPort = 0;
            version = "";
            osversion = "";
            locator = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(nodeName, 0);
            if (nodeObj != "")
            {
                _os.write(nodeObj, 1);
            }
            if (endpointIp != "")
            {
                _os.write(endpointIp, 2);
            }
            if (endpointPort != 0)
            {
                _os.write(endpointPort, 3);
            }
            if (version != "")
            {
                _os.write(version, 4);
            }
            if (osversion != "")
            {
                _os.write(osversion, 5);
            }
            if (locator != "")
            {
                _os.write(locator, 6);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(nodeName, 0, true);
            _is.read(nodeObj, 1, false);
            _is.read(endpointIp, 2, false);
            _is.read(endpointPort, 3, false);
            _is.read(version, 4, false);
            _is.read(osversion, 5, false);
            _is.read(locator, 6, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(nodeName,"nodeName");
            _ds.display(nodeObj,"nodeObj");
            _ds.display(endpointIp,"endpointIp");
            _ds.display(endpointPort,"endpointPort");
            _ds.display(version,"version");
            _ds.display(osversion,"osversion");
            _ds.display(locator,"locator");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(nodeName, true);
            _ds.displaySimple(nodeObj, true);
            _ds.displaySimple(endpointIp, true);
            _ds.displaySimple(endpointPort, true);
            _ds.displaySimple(version, true);
            _ds.displaySimple(osversion, true);
            _ds.displaySimple(locator, false);
            return _os;
        }
    public:
        std::string nodeName;
        std::string nodeObj;
        std::string endpointIp;
        tars::Int32 endpointPort;
        std::string version;
        std::string osversion;
        std::string locator;
    };
    inline bool operator==(const NodeInstanceInfo&l, const NodeInstanceInfo&r)
    {
        return l.nodeName == r.nodeName && l.nodeObj == r.nodeObj && l.endpointIp == r.endpointIp && l.endpointPort == r.endpointPort && l.version == r.version && l.osversion == r.osversion && l.locator == r.locator;
    }
    inline bool operator!=(const NodeInstanceInfo&l, const NodeInstanceInfo&r)
    {
        return !(l == r);
    }

    struct ServerStateInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Tseer.ServerStateInfo";
        }
        static string MD5()
        {
            return "37ba82ce86c9117f65de5437c606c10d";
        }
        ServerStateInfo()
        :serverState(Tseer::Inactive),processId(0),nodeName(""),application(""),serverName(""),containerName(""),moduleType(""),settingState(Tseer::Inactive),servant(""),endpointPort(0)
        {
        }
        void resetDefautlt()
        {
            processId = 0;
            nodeName = "";
            application = "";
            serverName = "";
            containerName = "";
            moduleType = "";
            servant = "";
            endpointPort = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write((tars::Int32)serverState, 0);
            _os.write(processId, 1);
            _os.write(nodeName, 2);
            _os.write(application, 3);
            _os.write(serverName, 4);
            _os.write(containerName, 5);
            _os.write(moduleType, 6);
            _os.write((tars::Int32)settingState, 7);
            _os.write(servant, 8);
            _os.write(endpointPort, 9);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            tars::Int32 eTemp0 = Tseer::Inactive;
            _is.read(eTemp0, 0, true);
            serverState = (Tseer::ServerState)eTemp0;
            _is.read(processId, 1, true);
            _is.read(nodeName, 2, true);
            _is.read(application, 3, true);
            _is.read(serverName, 4, true);
            _is.read(containerName, 5, true);
            _is.read(moduleType, 6, true);
            tars::Int32 eTemp7 = Tseer::Inactive;
            _is.read(eTemp7, 7, false);
            settingState = (Tseer::ServerState)eTemp7;
            _is.read(servant, 8, true);
            _is.read(endpointPort, 9, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display((tars::Int32)serverState,"serverState");
            _ds.display(processId,"processId");
            _ds.display(nodeName,"nodeName");
            _ds.display(application,"application");
            _ds.display(serverName,"serverName");
            _ds.display(containerName,"containerName");
            _ds.display(moduleType,"moduleType");
            _ds.display((tars::Int32)settingState,"settingState");
            _ds.display(servant,"servant");
            _ds.display(endpointPort,"endpointPort");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple((tars::Int32)serverState, true);
            _ds.displaySimple(processId, true);
            _ds.displaySimple(nodeName, true);
            _ds.displaySimple(application, true);
            _ds.displaySimple(serverName, true);
            _ds.displaySimple(containerName, true);
            _ds.displaySimple(moduleType, true);
            _ds.displaySimple((tars::Int32)settingState, true);
            _ds.displaySimple(servant, true);
            _ds.displaySimple(endpointPort, false);
            return _os;
        }
    public:
        Tseer::ServerState serverState;
        tars::Int32 processId;
        std::string nodeName;
        std::string application;
        std::string serverName;
        std::string containerName;
        std::string moduleType;
        Tseer::ServerState settingState;
        std::string servant;
        tars::Int32 endpointPort;
    };
    inline bool operator==(const ServerStateInfo&l, const ServerStateInfo&r)
    {
        return l.serverState == r.serverState && l.processId == r.processId && l.nodeName == r.nodeName && l.application == r.application && l.serverName == r.serverName && l.containerName == r.containerName && l.moduleType == r.moduleType && l.settingState == r.settingState && l.servant == r.servant && l.endpointPort == r.endpointPort;
    }
    inline bool operator!=(const ServerStateInfo&l, const ServerStateInfo&r)
    {
        return !(l == r);
    }


}



#endif
