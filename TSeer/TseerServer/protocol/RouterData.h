// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 1.1.0.
// **********************************************************************

#ifndef __ROUTERDATA_H_
#define __ROUTERDATA_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
using namespace std;


namespace Tseer
{
    struct RouterData : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Tseer.RouterData";
        }
        static string MD5()
        {
            return "29f042f2dd43fc12e4f1c5467dd2970e";
        }
        RouterData()
        :moduletype(""),application(""),service_name(""),node_name(""),container_name(""),enable_group(""),ip_group_name(""),enable_set(""),set_name(""),set_area(""),set_group(""),weight(""),setting_state(""),process_id(""),present_state(""),node_port(""),container_port(""),bak_flag(""),grid_flag(""),weighttype(""),enable_heartbeat(""),heartbeattimeout("60")
        {
        }
        void resetDefautlt()
        {
            moduletype = "";
            application = "";
            service_name = "";
            node_name = "";
            container_name = "";
            enable_group = "";
            ip_group_name = "";
            enable_set = "";
            set_name = "";
            set_area = "";
            set_group = "";
            weight = "";
            setting_state = "";
            process_id = "";
            present_state = "";
            node_port = "";
            container_port = "";
            bak_flag = "";
            grid_flag = "";
            weighttype = "";
            enable_heartbeat = "";
            heartbeattimeout = "60";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(moduletype, 0);
            _os.write(application, 1);
            _os.write(service_name, 2);
            _os.write(node_name, 3);
            _os.write(container_name, 4);
            _os.write(enable_group, 5);
            _os.write(ip_group_name, 6);
            _os.write(enable_set, 7);
            _os.write(set_name, 8);
            _os.write(set_area, 9);
            _os.write(set_group, 10);
            _os.write(weight, 11);
            _os.write(setting_state, 12);
            _os.write(process_id, 13);
            _os.write(present_state, 14);
            _os.write(node_port, 15);
            _os.write(container_port, 16);
            _os.write(servant, 17);
            _os.write(bak_flag, 18);
            _os.write(grid_flag, 19);
            if (weighttype != "")
            {
                _os.write(weighttype, 20);
            }
            if (enable_heartbeat != "")
            {
                _os.write(enable_heartbeat, 21);
            }
            if (heartbeattimeout != "60")
            {
                _os.write(heartbeattimeout, 22);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(moduletype, 0, true);
            _is.read(application, 1, true);
            _is.read(service_name, 2, true);
            _is.read(node_name, 3, true);
            _is.read(container_name, 4, true);
            _is.read(enable_group, 5, true);
            _is.read(ip_group_name, 6, true);
            _is.read(enable_set, 7, true);
            _is.read(set_name, 8, true);
            _is.read(set_area, 9, true);
            _is.read(set_group, 10, true);
            _is.read(weight, 11, true);
            _is.read(setting_state, 12, true);
            _is.read(process_id, 13, true);
            _is.read(present_state, 14, true);
            _is.read(node_port, 15, true);
            _is.read(container_port, 16, true);
            _is.read(servant, 17, true);
            _is.read(bak_flag, 18, true);
            _is.read(grid_flag, 19, true);
            _is.read(weighttype, 20, false);
            _is.read(enable_heartbeat, 21, false);
            _is.read(heartbeattimeout, 22, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(moduletype,"moduletype");
            _ds.display(application,"application");
            _ds.display(service_name,"service_name");
            _ds.display(node_name,"node_name");
            _ds.display(container_name,"container_name");
            _ds.display(enable_group,"enable_group");
            _ds.display(ip_group_name,"ip_group_name");
            _ds.display(enable_set,"enable_set");
            _ds.display(set_name,"set_name");
            _ds.display(set_area,"set_area");
            _ds.display(set_group,"set_group");
            _ds.display(weight,"weight");
            _ds.display(setting_state,"setting_state");
            _ds.display(process_id,"process_id");
            _ds.display(present_state,"present_state");
            _ds.display(node_port,"node_port");
            _ds.display(container_port,"container_port");
            _ds.display(servant,"servant");
            _ds.display(bak_flag,"bak_flag");
            _ds.display(grid_flag,"grid_flag");
            _ds.display(weighttype,"weighttype");
            _ds.display(enable_heartbeat,"enable_heartbeat");
            _ds.display(heartbeattimeout,"heartbeattimeout");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(moduletype, true);
            _ds.displaySimple(application, true);
            _ds.displaySimple(service_name, true);
            _ds.displaySimple(node_name, true);
            _ds.displaySimple(container_name, true);
            _ds.displaySimple(enable_group, true);
            _ds.displaySimple(ip_group_name, true);
            _ds.displaySimple(enable_set, true);
            _ds.displaySimple(set_name, true);
            _ds.displaySimple(set_area, true);
            _ds.displaySimple(set_group, true);
            _ds.displaySimple(weight, true);
            _ds.displaySimple(setting_state, true);
            _ds.displaySimple(process_id, true);
            _ds.displaySimple(present_state, true);
            _ds.displaySimple(node_port, true);
            _ds.displaySimple(container_port, true);
            _ds.displaySimple(servant, true);
            _ds.displaySimple(bak_flag, true);
            _ds.displaySimple(grid_flag, true);
            _ds.displaySimple(weighttype, true);
            _ds.displaySimple(enable_heartbeat, true);
            _ds.displaySimple(heartbeattimeout, false);
            return _os;
        }
    public:
        std::string moduletype;
        std::string application;
        std::string service_name;
        std::string node_name;
        std::string container_name;
        std::string enable_group;
        std::string ip_group_name;
        std::string enable_set;
        std::string set_name;
        std::string set_area;
        std::string set_group;
        std::string weight;
        std::string setting_state;
        std::string process_id;
        std::string present_state;
        std::string node_port;
        std::string container_port;
        map<std::string, std::string> servant;
        std::string bak_flag;
        std::string grid_flag;
        std::string weighttype;
        std::string enable_heartbeat;
        std::string heartbeattimeout;
    };
    inline bool operator==(const RouterData&l, const RouterData&r)
    {
        return l.moduletype == r.moduletype && l.application == r.application && l.service_name == r.service_name && l.node_name == r.node_name && l.container_name == r.container_name && l.enable_group == r.enable_group && l.ip_group_name == r.ip_group_name && l.enable_set == r.enable_set && l.set_name == r.set_name && l.set_area == r.set_area && l.set_group == r.set_group && l.weight == r.weight && l.setting_state == r.setting_state && l.process_id == r.process_id && l.present_state == r.present_state && l.node_port == r.node_port && l.container_port == r.container_port && l.servant == r.servant && l.bak_flag == r.bak_flag && l.grid_flag == r.grid_flag && l.weighttype == r.weighttype && l.enable_heartbeat == r.enable_heartbeat && l.heartbeattimeout == r.heartbeattimeout;
    }
    inline bool operator!=(const RouterData&l, const RouterData&r)
    {
        return !(l == r);
    }

    struct RouterDataRequest : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "Tseer.RouterDataRequest";
        }
        static string MD5()
        {
            return "c73c13678f156f762d622e8672930c1d";
        }
        RouterDataRequest()
        :moduletype(""),application(""),service_name(""),node_name(""),container_name("")
        {
        }
        void resetDefautlt()
        {
            moduletype = "";
            application = "";
            service_name = "";
            node_name = "";
            container_name = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(moduletype, 0);
            _os.write(application, 1);
            _os.write(service_name, 2);
            _os.write(node_name, 3);
            _os.write(container_name, 4);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(moduletype, 0, true);
            _is.read(application, 1, true);
            _is.read(service_name, 2, true);
            _is.read(node_name, 3, true);
            _is.read(container_name, 4, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(moduletype,"moduletype");
            _ds.display(application,"application");
            _ds.display(service_name,"service_name");
            _ds.display(node_name,"node_name");
            _ds.display(container_name,"container_name");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(moduletype, true);
            _ds.displaySimple(application, true);
            _ds.displaySimple(service_name, true);
            _ds.displaySimple(node_name, true);
            _ds.displaySimple(container_name, false);
            return _os;
        }
    public:
        std::string moduletype;
        std::string application;
        std::string service_name;
        std::string node_name;
        std::string container_name;
    };
    inline bool operator==(const RouterDataRequest&l, const RouterDataRequest&r)
    {
        return l.moduletype == r.moduletype && l.application == r.application && l.service_name == r.service_name && l.node_name == r.node_name && l.container_name == r.container_name;
    }
    inline bool operator!=(const RouterDataRequest&l, const RouterDataRequest&r)
    {
        return !(l == r);
    }
    inline bool operator<(const RouterDataRequest&l, const RouterDataRequest&r)
    {
        if(l.moduletype != r.moduletype)  return (l.moduletype < r.moduletype);
        if(l.application != r.application)  return (l.application < r.application);
        if(l.service_name != r.service_name)  return (l.service_name < r.service_name);
        if(l.node_name != r.node_name)  return (l.node_name < r.node_name);
        if(l.container_name != r.container_name)  return (l.container_name < r.container_name);
        return false;
    }
    inline bool operator<=(const RouterDataRequest&l, const RouterDataRequest&r)
    {
        return !(r < l);
    }
    inline bool operator>(const RouterDataRequest&l, const RouterDataRequest&r)
    {
        return r < l;
    }
    inline bool operator>=(const RouterDataRequest&l, const RouterDataRequest&r)
    {
        return !(l < r);
    }


}



#endif
